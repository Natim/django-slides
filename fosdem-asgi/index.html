<html>
<head>
  <meta charset="utf-8">
  <title>ASGI — Django 3.0 entering a new dimension</title>
  <link rel="stylesheet" href="./dist/talkie.min.css">
  <link rel="stylesheet" href="./dist/talkie-default.min.css">
  <link rel="stylesheet" href="./dist/monokai_sublime.min.css">
  <link rel="stylesheet" href="./dist/mozilla.css">
</head>
<body>

<template layout="cover" type="text/x-markdown"
          backface="./images/cover.png">


</template>

<template layout="title" type="text/x-markdown"
          backface="./images/cover-no-logo-bottom.png">

## Who am I?

</template>


<template layout="bullets" type="text/x-markdown"
          backface="./images/cover-logo.png">
## Who am I?

- My name is Rémy Hubscher — [@natim](https://twitter.com/natim)
- I am Python Backend developer since 2005
- I Worked with PeopleDoc, Mozilla, Chefclub, Alma

![peopledoc](./images/logos/peopledoc.resized.jpg)
![mozilla](./images/logos/mozilla-org.resized.png)
![chefclub](./images/logos/chefclub.resized.png)

![python](./images/logos/python.resized.png)
</template>

<template layout="title" type="text/x-markdown"
          backface="./images/cover-no-logo-bottom.png">

## What is Django?

</template>

<template layout="bullets" type="text/x-markdown"
          backface="./images/cover-no-logo.png">

## What is Django?

- Django is a Python web framework
- Its development started in 2003.
- Got famous because of its autogenerated and configurable admin interface.

![Django](./images/logos/django.png)

</template>

<template layout="bullets" type="text/x-markdown"
          backface="./images/cover-no-logo.png">

A few years ago, Andrew Godwin started to think about async Django.
- Compatible with both Python 2 and Python 3.
- With no breaking changes

![Andrew Godwin](./images/andrewgodwin.jpg)

</template>
<template layout="bullets" type="text/x-markdown"
          backface="./images/cover-no-logo.png">
## Django Channels
    
- Andrew started a kickstarter to champion this.
- This lead to the Channels project
- The ASGI protocol as well as tooling around ASGI
- The Daphne server
- Redis Channels queue implementation

</template>

<template layout="bullets" type="text/x-markdown"
          backface="./images/cover-no-logo.png">

## Disclamer

- In 2019, the [DEP-009](https://github.com/django/deps/blob/master/accepted/0009-async.rst)
  for an Async-capable Django got accepted
- Django 3.0 started adding ASGI support.
- For this reason, this talk will be focused on ASGI.
</template>

<template layout="title" type="text/x-markdown"
          backface="./images/cover-no-logo-bottom.png">

## Let me ask some questions

</template>

<template layout="title" type="text/x-markdown"
          backface="./images/cover-no-logo-bottom.png">

## Who heard of CGI?

</template>

<template layout="bullets" type="text/x-markdown"
          backface="./images/cover-no-logo.png">

## Common Gateway Interface

- First specification written in 1973 by the NCSA
- The goal is to delegate HTTP request handling to a CLI tool.
- In October 2004, the RFC 3875 specified CGI version 1.1
</template>


<template layout="title" type="text/x-markdown"
          backface="./images/cover-no-logo-bottom.png">

## Who is familiar with WSGI?

</template>

<template layout="bullets" type="text/x-markdown"
          backface="./images/cover-no-logo.png">
## Web Server Gateway Interface

- WSGI was originally specified as PEP-333 in 2003.
- An implementation-agnostic interface between web servers and web applications.
- Aimed to standardize Python web frameworks.
- In 2010, PEP-3333 updates the specification for Python 3.

![WSGI Python App](./images/wsgi-example.png)
</template>

<template layout="title" type="text/x-markdown"
          backface="./images/cover-no-logo-bottom.png">

## Who heard of ASGI?

</template>

<template layout="bullets" type="text/x-markdown"
          backface="./images/cover-no-logo.png">
## Async Server Gateway Interface

- Wikipedia does not know about ASGI yet.
- It's the spiritual successor to WSGI.
- Provides a standard interface for async Python web servers.
</template>


<template layout="title" type="text/x-markdown"
          backface="./images/cover-no-logo-bottom.png">
## Why not keep WSGI?

![standards](./images/standards.png)
</template>


<template layout="bullets" type="text/x-markdown"
          backface="./images/cover-no-logo.png">
## How does WSGI work?
    
- WSGI passes an environ with the request information.
- The Python application computes the response
- The response is sent back and a new request can be handled.

</template>

<template layout="bullets" type="text/x-markdown"
          backface="./images/cover-no-logo.png">
![overview](./images/http-1.x.png)
</template>
<template layout="bullets" type="text/x-markdown"
          backface="./images/cover-no-logo.png">
## What's wrong with WSGI?

1. If the response takes time, other clients have to wait.
2. A worker cannot handle multiple clients at the same time.
3. To mitigate that we spawn multiple workers.
</template>

<template layout="title" type="text/x-markdown"
          backface="./images/cover-no-logo-bottom.png">
## Has anyone had to work with websocket and Python?
</template>

<template layout="bullets" type="text/x-markdown"
          backface="./images/cover-no-logo.png">

## Websockets

- Websockets need one connection per user.
- It doesn't fit in WSGI request/response model.
- We can't afford to have a worker per client.

</template>

<template layout="bullets" type="text/x-markdown"
          backface="./images/cover-no-logo.png">

![overview](./images/websockets.png)

</template>

<template layout="title" type="text/x-markdown"
          backface="./images/cover-no-logo.png">
## What about HTTP/2 or HTTP/3?
</template>

<template layout="bullets" type="text/x-markdown"
          backface="./images/cover-no-logo.png">
## HTTP/2

- A unique connection opened per user
- A client state on the server side
- A binary protocol that allows response for different requests to be mixed
</template>

<template layout="bullets" type="text/x-markdown"
          backface="./images/cover-no-logo.png">
## HTTP/2

- You can ask for multiple files without waiting for the answer
- You can prioritize what response are the most important to you
- The server can push files you may need without you requesting them.

</template>

<template layout="bullets" type="text/x-markdown"
          backface="./images/cover-no-logo.png">

![overview](./images/http-2.x.png)

</template>

<template layout="bullets" type="text/x-markdown"
          backface="./images/cover-no-logo.png">
## HTTP/3

- HTTP/3 was previously called QUICK.
- It is an improvment of HTTP/2 that works on top of UDP instead of TCP
- I encourage you to watch Daniel Stenberg's talk about HTTP/3 this afternoon.

</template>

<template layout="bullets" type="text/x-markdown"
          backface="./images/cover-no-logo.png">
# To conclude on WSGI

- WSGI servers (uWSGI, gunicorn) are really good at hidding these restrictions.
- If the request/response model fits your needs, then WSGI is good enough.
- WSGI's synchronous response model is limiting for the asynchronous web we use today.
</template>

<template layout="title" type="text/x-markdown"
          backface="./images/cover-no-logo-bottom.png">
# The ASGI promise
</template>

<template layout="title" type="text/x-markdown"
          backface="./images/cover-no-logo.png">

![ASGI Architecture](./images/asgi.png)
    
</template>

<template layout="bullets" type="text/x-markdown"
          backface="./images/cover-no-logo.png">
## An event based protocol

- ASGI describes events instead of requests and responses.
- ASGI servers keep tabs on client sockets. (i.e Daphne, Univcorn)
- The ASGI server pushes new events to a queue.
- Workers handle JSON events from the queue.
- A HTTP request is just another kind of event.
- You can use workers for async background tasks as well.
</template>

<template layout="bullets" type="text/x-markdown"
          backface="./images/cover-no-logo.png">

## An asynchronous server written in synchronous mode.

- The server is handling all the asynchronous complexity
- Handling a task can be synchronous
- Your worker don't have to be asynchronous
</template>


<template layout="bullets" type="text/x-markdown"
          backface="./images/cover-no-logo.png">
## ASGI is already popular

- ASGI is already mainstream in **startlette** and **fastapi**
- Django 3 shipped an ASGI endpoint, next versions should embed more tooling.
- If you want the most of ASGI and Django, you can start today with Django Channels.
- If you find yourself needing Celery, you can actually benefit from the
ASGI worker architecture instead and simplify architecture using channels background tasks.
</template>

<template layout="bullets" type="text/x-markdown"
          backface="./images/cover-no-logo.png">
## As a conclusion

- If you do backend web development in Python, you should learn more about ASGI.
- If you never heard about Starlette or FastAPI before, you should definitely try them.
- If you never tried asyncio find some time in 2020 to try it.
</template>

<template layout="bullets" type="text/x-markdown"
          backface="./images/cover-empty.png">

- Thank you for your attention
- My name is Rémy Hubscher — [@natim](https://twitter.com/natim)
- Feel free to ask me your questions.
- To learn more please visit [getalma.eu](https://www.getalma.eu/)
</template>



<script src="./dist/highlight.min.js"></script>
<script src="./dist/talkie.js"></script>
<script>
var talkie = Talkie({wide: false});

talkie.next.plug(talkie.control.keydown('s'));
talkie.next.plug(talkie.control.keydown('n'));
talkie.prev.plug(talkie.control.keydown('a'));
talkie.prev.plug(talkie.control.keydown('p'));

document.addEventListener('DOMContentLoaded', function() {
  var slides = Array.prototype.slice.call(document.querySelectorAll('[layout]'));
  talkie.changed.onValue(function(current) {
    console.clear();
    // print presenter notes
    console.info(talkie.notes[current.getAttribute('page')]);
  });
});
</script>
</body>
</html>
